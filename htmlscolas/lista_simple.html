<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lista Enlazada Simple (Lineal) - Visualizador</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    .nodo-highlight {
      animation: pulse 0.5s ease-in-out;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.15); }
    }
    .nodo-encontrado {
      animation: encontrado 0.8s ease-in-out infinite;
    }
    @keyframes encontrado {
      0%, 100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); }
      50% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
    }
  </style>
</head>
<body class="bg-gray-900 min-h-screen">
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState } = React;

    // Clase Nodo para lista simple lineal
    class Nodo {
      constructor(dato) {
        this.dato = dato;
        this.sig = null; // Solo un puntero (siguiente), termina en NULL
        this.id = Math.random().toString(36).substr(2, 9);
      }
    }

    function ListaLinealVisualizer() {
      const [cabecera, setCabecera] = useState(() => {
        const p = new Nodo('P');
        p.esCabecera = true;
        p.sig = null; // En lista lineal, termina en NULL
        return p;
      });
      const [valor, setValor] = useState('');
      const [valorRef, setValorRef] = useState('');
      const [valorBusqueda, setValorBusqueda] = useState('');
      const [mensaje, setMensaje] = useState('');
      const [nodoActivo, setNodoActivo] = useState(null);
      const [nodoEncontrado, setNodoEncontrado] = useState(null);
      const [pasoAlgoritmo, setPasoAlgoritmo] = useState([]);
      const [mostrarInfo, setMostrarInfo] = useState(true);
      const [velocidad, setVelocidad] = useState(600);
      const [metodoActual, setMetodoActual] = useState(null);

      // Verificar si la lista est√° vac√≠a
      const estaVacia = () => cabecera.sig === null;

      // Convertir lista a array para renderizar
      const obtenerNodos = () => {
        const nodos = [cabecera];
        let actual = cabecera.sig;
        while (actual !== null) {
          nodos.push(actual);
          actual = actual.sig;
        }
        return nodos;
      };

      // Clonar lista
      const clonarLista = () => {
        const nuevaCabecera = new Nodo('P');
        nuevaCabecera.esCabecera = true;
        
        let actualOriginal = cabecera.sig;
        let ultimoNuevo = nuevaCabecera;
        
        while (actualOriginal !== null) {
          const nuevoNodo = new Nodo(actualOriginal.dato);
          ultimoNuevo.sig = nuevoNodo;
          ultimoNuevo = nuevoNodo;
          actualOriginal = actualOriginal.sig;
        }
        
        return nuevaCabecera;
      };

      // ==================== M√âTODOS DE INSERCI√ìN ====================

      const insertarAlInicio = async () => {
        if (!valor.trim()) {
          setMensaje('‚ö†Ô∏è Ingresa un valor');
          return;
        }

        setMetodoActual('insertarInicio');
        const pasos = [
          { texto: 'INSERTAR AL INICIO (Lista Lineal)', tipo: 'titulo' },
          { texto: `Nuevo dato: "${valor}"`, tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Crear nuevo nodo Q', tipo: 'info' },
          { texto: '2. Q.sig = P.sig (apuntar al primer nodo actual)', tipo: 'info' },
          { texto: '3. P.sig = Q (cabecera apunta al nuevo)', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);

        await new Promise(r => setTimeout(r, velocidad));

        const nuevaCabecera = clonarLista();
        const nuevoNodo = new Nodo(valor);
        
        pasos.push({ texto: `Crear nodo Q con dato "${valor}"`, tipo: 'operacion' });
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        nuevoNodo.sig = nuevaCabecera.sig;
        
        pasos.push({ texto: `Q.sig = P.sig ${nuevaCabecera.sig ? `(apunta a "${nuevaCabecera.sig.dato}")` : '(NULL - lista estaba vac√≠a)'}`, tipo: 'operacion' });
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        nuevaCabecera.sig = nuevoNodo;
        pasos.push({ texto: 'P.sig = Q (cabecera apunta al nuevo nodo)', tipo: 'operacion' });
        pasos.push({ texto: `‚úì Nodo "${valor}" insertado al inicio`, tipo: 'exito' });
        setPasoAlgoritmo([...pasos]);

        setCabecera(nuevaCabecera);
        setNodoActivo(nuevoNodo.id);
        setTimeout(() => setNodoActivo(null), 1000);
        setMensaje(`‚úÖ "${valor}" insertado al inicio`);
        setValor('');
        setMetodoActual(null);
      };

      const insertarAlFinal = async () => {
        if (!valor.trim()) {
          setMensaje('‚ö†Ô∏è Ingresa un valor');
          return;
        }

        setMetodoActual('insertarFinal');
        const pasos = [
          { texto: 'INSERTAR AL FINAL (Lista Lineal)', tipo: 'titulo' },
          { texto: `Nuevo dato: "${valor}"`, tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Q = P (comenzar en cabecera)', tipo: 'info' },
          { texto: '2. Mientras Q.sig != NULL: Q = Q.sig', tipo: 'info' },
          { texto: '   (buscar el √∫ltimo nodo)', tipo: 'info' },
          { texto: '3. Crear nuevo nodo', tipo: 'info' },
          { texto: '4. Q.sig = NuevoNodo', tipo: 'info' },
          { texto: '5. NuevoNodo.sig = NULL', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);

        const nuevaCabecera = clonarLista();
        let Q = nuevaCabecera;

        pasos.push({ texto: 'Q = P (comenzar en cabecera)', tipo: 'operacion' });
        setPasoAlgoritmo([...pasos]);
        setNodoActivo(nuevaCabecera.id);
        await new Promise(r => setTimeout(r, velocidad));

        while (Q.sig !== null) {
          pasos.push({ texto: `Q.sig != NULL ‚Üí Q = Q.sig (avanzar a "${Q.sig.dato}")`, tipo: 'operacion' });
          Q = Q.sig;
          setPasoAlgoritmo([...pasos]);
          setNodoActivo(Q.id);
          await new Promise(r => setTimeout(r, velocidad));
        }

        pasos.push({ texto: 'Q.sig == NULL ‚Üí Encontramos el final', tipo: 'info' });
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        const nuevoNodo = new Nodo(valor);
        nuevoNodo.sig = null; // Termina en NULL
        Q.sig = nuevoNodo;

        pasos.push({ texto: `Crear nodo con dato "${valor}"`, tipo: 'operacion' });
        pasos.push({ texto: 'NuevoNodo.sig = NULL (es el nuevo √∫ltimo)', tipo: 'operacion' });
        pasos.push({ texto: 'Q.sig = NuevoNodo', tipo: 'operacion' });
        pasos.push({ texto: `‚úì Nodo "${valor}" insertado al final`, tipo: 'exito' });
        setPasoAlgoritmo([...pasos]);

        setCabecera(nuevaCabecera);
        setNodoActivo(nuevoNodo.id);
        setTimeout(() => setNodoActivo(null), 1000);
        setMensaje(`‚úÖ "${valor}" insertado al final`);
        setValor('');
        setMetodoActual(null);
      };

      const insertarDespuesDe = async () => {
        if (!valor.trim() || !valorRef.trim()) {
          setMensaje('‚ö†Ô∏è Ingresa el valor y la referencia');
          return;
        }

        if (estaVacia()) {
          setMensaje('‚ùå Lista vac√≠a');
          return;
        }

        setMetodoActual('insertarDespues');
        const pasos = [
          { texto: 'INSERTAR DESPU√âS DE (Lista Lineal)', tipo: 'titulo' },
          { texto: `Nuevo dato: "${valor}", Referencia: "${valorRef}"`, tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Q = P.sig (primer nodo)', tipo: 'info' },
          { texto: '2. Mientras Q != NULL Y Q.dato != ref: Q = Q.sig', tipo: 'info' },
          { texto: '3. Si Q != NULL: insertar despu√©s de Q', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);

        const nuevaCabecera = clonarLista();
        let Q = nuevaCabecera.sig;

        pasos.push({ texto: `Q = P.sig (comenzar en "${Q.dato}")`, tipo: 'operacion' });
        setNodoActivo(Q.id);
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        while (Q !== null && Q.dato !== valorRef) {
          pasos.push({ texto: `"${Q.dato}" != "${valorRef}" ‚Üí Q = Q.sig`, tipo: 'operacion' });
          Q = Q.sig;
          if (Q !== null) {
            setNodoActivo(Q.id);
            pasos.push({ texto: `Ahora Q apunta a "${Q.dato}"`, tipo: 'info' });
          }
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));
        }

        if (Q !== null) {
          pasos.push({ texto: `¬°Encontrado! Q.dato == "${valorRef}"`, tipo: 'exito' });
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));

          const nuevoNodo = new Nodo(valor);
          nuevoNodo.sig = Q.sig;
          Q.sig = nuevoNodo;

          pasos.push({ texto: `NuevoNodo.sig = Q.sig ${Q.sig ? '' : '(NULL)'}`, tipo: 'operacion' });
          pasos.push({ texto: `Q.sig = NuevoNodo`, tipo: 'operacion' });
          pasos.push({ texto: `‚úì "${valor}" insertado despu√©s de "${valorRef}"`, tipo: 'exito' });
          setPasoAlgoritmo([...pasos]);

          setCabecera(nuevaCabecera);
          setNodoActivo(nuevoNodo.id);
          setTimeout(() => setNodoActivo(null), 1000);
          setMensaje(`‚úÖ "${valor}" insertado despu√©s de "${valorRef}"`);
        } else {
          pasos.push({ texto: `Q == NULL (llegamos al final)`, tipo: 'info' });
          pasos.push({ texto: `‚ùå No se encontr√≥ "${valorRef}"`, tipo: 'error' });
          setPasoAlgoritmo([...pasos]);
          setMensaje(`‚ùå No se encontr√≥ "${valorRef}"`);
        }

        setValor('');
        setValorRef('');
        setMetodoActual(null);
      };

      // ==================== M√âTODOS DE ELIMINACI√ìN ====================

      const eliminarPrimero = async () => {
        if (estaVacia()) {
          setMensaje('‚ùå Lista vac√≠a');
          return;
        }

        setMetodoActual('eliminarPrimero');
        const pasos = [
          { texto: 'ELIMINAR PRIMER NODO (Lista Lineal)', tipo: 'titulo' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Si P.sig == NULL: lista vac√≠a', tipo: 'info' },
          { texto: '2. P.sig = P.sig.sig (saltar el primer nodo)', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);

        const nuevaCabecera = clonarLista();
        const nodoAEliminar = nuevaCabecera.sig;
        const datoEliminado = nodoAEliminar.dato;

        pasos.push({ texto: `Nodo a eliminar: "${datoEliminado}"`, tipo: 'info' });
        setNodoActivo(nodoAEliminar.id);
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        nuevaCabecera.sig = nodoAEliminar.sig;

        if (nuevaCabecera.sig === null) {
          pasos.push({ texto: 'P.sig = NULL (lista queda vac√≠a)', tipo: 'operacion' });
        } else {
          pasos.push({ texto: `P.sig = P.sig.sig (ahora apunta a "${nuevaCabecera.sig.dato}")`, tipo: 'operacion' });
        }

        pasos.push({ texto: `‚úì Nodo "${datoEliminado}" eliminado del inicio`, tipo: 'exito' });
        setPasoAlgoritmo([...pasos]);

        setCabecera(nuevaCabecera);
        setNodoActivo(null);
        setMensaje(`‚úÖ "${datoEliminado}" eliminado del inicio`);
        setMetodoActual(null);
      };

      const eliminarUltimo = async () => {
        if (estaVacia()) {
          setMensaje('‚ùå Lista vac√≠a');
          return;
        }

        setMetodoActual('eliminarUltimo');
        const pasos = [
          { texto: 'ELIMINAR √öLTIMO NODO (Lista Lineal)', tipo: 'titulo' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Q = P (comenzar en cabecera)', tipo: 'info' },
          { texto: '2. Mientras Q.sig.sig != NULL: Q = Q.sig', tipo: 'info' },
          { texto: '   (buscar el pen√∫ltimo nodo)', tipo: 'info' },
          { texto: '3. Q.sig = NULL (eliminar el √∫ltimo)', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);

        const nuevaCabecera = clonarLista();
        let Q = nuevaCabecera;

        pasos.push({ texto: 'Q = P (comenzar en cabecera)', tipo: 'operacion' });
        setNodoActivo(nuevaCabecera.id);
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        // Caso especial: solo hay un nodo
        if (Q.sig.sig === null) {
          const datoEliminado = Q.sig.dato;
          pasos.push({ texto: `Solo hay un nodo: "${datoEliminado}"`, tipo: 'info' });
          setNodoActivo(Q.sig.id);
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));

          nuevaCabecera.sig = null;
          pasos.push({ texto: 'P.sig = NULL (lista queda vac√≠a)', tipo: 'operacion' });
          pasos.push({ texto: `‚úì Nodo "${datoEliminado}" eliminado`, tipo: 'exito' });
          setPasoAlgoritmo([...pasos]);

          setCabecera(nuevaCabecera);
          setNodoActivo(null);
          setMensaje(`‚úÖ "${datoEliminado}" eliminado del final`);
          setMetodoActual(null);
          return;
        }

        while (Q.sig.sig !== null) {
          pasos.push({ texto: `Q.sig.sig != NULL ‚Üí Q = Q.sig (avanzar a "${Q.sig.dato}")`, tipo: 'operacion' });
          Q = Q.sig;
          setNodoActivo(Q.id);
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));
        }

        const datoEliminado = Q.sig.dato;
        pasos.push({ texto: `Q.sig.sig == NULL ‚Üí "${Q.sig.dato}" es el √∫ltimo`, tipo: 'info' });
        setNodoActivo(Q.sig.id);
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        Q.sig = null;
        pasos.push({ texto: 'Q.sig = NULL', tipo: 'operacion' });
        pasos.push({ texto: `‚úì Nodo "${datoEliminado}" eliminado del final`, tipo: 'exito' });
        setPasoAlgoritmo([...pasos]);

        setCabecera(nuevaCabecera);
        setNodoActivo(null);
        setMensaje(`‚úÖ "${datoEliminado}" eliminado del final`);
        setMetodoActual(null);
      };

      const eliminarPorDato = async () => {
        if (!valorBusqueda.trim()) {
          setMensaje('‚ö†Ô∏è Ingresa el dato a eliminar');
          return;
        }

        if (estaVacia()) {
          setMensaje('‚ùå Lista vac√≠a');
          return;
        }

        setMetodoActual('eliminarPorDato');
        const pasos = [
          { texto: 'ELIMINAR NODO POR DATO (Lista Lineal)', tipo: 'titulo' },
          { texto: `Dato a eliminar: "${valorBusqueda}"`, tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Q = P (comenzar en cabecera)', tipo: 'info' },
          { texto: '2. Mientras Q.sig != NULL Y Q.sig.dato != dato:', tipo: 'info' },
          { texto: '   Q = Q.sig', tipo: 'info' },
          { texto: '3. Si Q.sig != NULL: Q.sig = Q.sig.sig', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);

        const nuevaCabecera = clonarLista();
        let Q = nuevaCabecera;

        pasos.push({ texto: 'Q = P (comenzar en cabecera)', tipo: 'operacion' });
        setNodoActivo(nuevaCabecera.id);
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        while (Q.sig !== null && Q.sig.dato !== valorBusqueda) {
          pasos.push({ texto: `"${Q.sig.dato}" != "${valorBusqueda}" ‚Üí Q = Q.sig`, tipo: 'operacion' });
          Q = Q.sig;
          setNodoActivo(Q.id);
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));
        }

        if (Q.sig !== null) {
          pasos.push({ texto: `¬°Encontrado! Q.sig.dato == "${valorBusqueda}"`, tipo: 'exito' });
          setNodoEncontrado(Q.sig.id);
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));

          Q.sig = Q.sig.sig;

          if (Q.sig === null) {
            pasos.push({ texto: 'Q.sig = NULL (era el √∫ltimo)', tipo: 'operacion' });
          } else {
            pasos.push({ texto: `Q.sig = Q.sig.sig (ahora apunta a "${Q.sig.dato}")`, tipo: 'operacion' });
          }

          pasos.push({ texto: `‚úì Nodo "${valorBusqueda}" eliminado`, tipo: 'exito' });
          setPasoAlgoritmo([...pasos]);

          setCabecera(nuevaCabecera);
          setMensaje(`‚úÖ "${valorBusqueda}" eliminado`);
        } else {
          pasos.push({ texto: `Q.sig == NULL (llegamos al final)`, tipo: 'info' });
          pasos.push({ texto: `‚ùå No se encontr√≥ "${valorBusqueda}"`, tipo: 'error' });
          setPasoAlgoritmo([...pasos]);
          setMensaje(`‚ùå No se encontr√≥ "${valorBusqueda}"`);
        }

        setNodoActivo(null);
        setNodoEncontrado(null);
        setValorBusqueda('');
        setMetodoActual(null);
      };

      // ==================== M√âTODO DE B√öSQUEDA ====================

      const buscarNodo = async () => {
        if (!valorBusqueda.trim()) {
          setMensaje('‚ö†Ô∏è Ingresa el dato a buscar');
          return;
        }

        if (estaVacia()) {
          setMensaje('‚ùå Lista vac√≠a');
          return;
        }

        setMetodoActual('buscar');
        const pasos = [
          { texto: 'B√öSQUEDA EN LISTA LINEAL', tipo: 'titulo' },
          { texto: `Dato a buscar: "${valorBusqueda}"`, tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üìñ Algoritmo:', tipo: 'titulo' },
          { texto: '1. Q = P.sig (primer nodo)', tipo: 'info' },
          { texto: '2. Mientras Q != NULL:', tipo: 'info' },
          { texto: '   - Si Q.dato == buscado: ¬°Encontrado!', tipo: 'info' },
          { texto: '   - Q = Q.sig', tipo: 'info' },
          { texto: '3. Si Q == NULL: No encontrado', tipo: 'info' },
          { texto: '', tipo: 'separador' },
          { texto: 'üîÑ Ejecuci√≥n:', tipo: 'titulo' }
        ];
        setPasoAlgoritmo([...pasos]);
        setNodoEncontrado(null);

        let Q = cabecera.sig;
        let posicion = 1;

        pasos.push({ texto: 'Q = P.sig, posici√≥n = 1', tipo: 'operacion' });
        setNodoActivo(Q.id);
        setPasoAlgoritmo([...pasos]);
        await new Promise(r => setTimeout(r, velocidad));

        while (Q !== null) {
          pasos.push({ texto: `Paso ${posicion}: Comparar "${Q.dato}" con "${valorBusqueda}"`, tipo: 'info' });
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));

          if (Q.dato === valorBusqueda) {
            pasos.push({ texto: `¬ø"${Q.dato}" == "${valorBusqueda}"? ¬°S√ç!`, tipo: 'condicion', cumple: true });
            pasos.push({ texto: `‚úì Encontrado en posici√≥n ${posicion}`, tipo: 'exito' });
            setPasoAlgoritmo([...pasos]);
            setNodoEncontrado(Q.id);
            setNodoActivo(null);
            setMensaje(`‚úÖ "${valorBusqueda}" encontrado en posici√≥n ${posicion}`);
            setMetodoActual(null);
            return;
          }

          pasos.push({ texto: `¬ø"${Q.dato}" == "${valorBusqueda}"? NO`, tipo: 'condicion', cumple: false });
          pasos.push({ texto: 'Q = Q.sig', tipo: 'operacion' });
          setPasoAlgoritmo([...pasos]);

          Q = Q.sig;
          posicion++;

          if (Q !== null) {
            setNodoActivo(Q.id);
            await new Promise(r => setTimeout(r, velocidad));
          }
        }

        pasos.push({ texto: 'Q == NULL (llegamos al final)', tipo: 'info' });
        pasos.push({ texto: `‚ùå "${valorBusqueda}" no se encontr√≥`, tipo: 'error' });
        setPasoAlgoritmo([...pasos]);
        setNodoActivo(null);
        setMensaje(`‚ùå "${valorBusqueda}" no encontrado`);
        setMetodoActual(null);
      };

      // ==================== RECORRIDO ====================

      const recorrido = async () => {
        if (estaVacia()) {
          setMensaje('‚ùå Lista vac√≠a');
          return;
        }

        setMetodoActual('recorrido');
        const pasos = [
          { texto: 'RECORRIDO LISTA LINEAL', tipo: 'titulo' },
          { texto: 'Desde P.sig hasta NULL', tipo: 'info' },
          { texto: '', tipo: 'separador' }
        ];
        setPasoAlgoritmo([...pasos]);

        let Q = cabecera.sig;
        let posicion = 1;

        while (Q !== null) {
          pasos.push({ texto: `Posici√≥n ${posicion}: "${Q.dato}"`, tipo: 'exito' });
          setNodoActivo(Q.id);
          setPasoAlgoritmo([...pasos]);
          await new Promise(r => setTimeout(r, velocidad));
          Q = Q.sig;
          posicion++;
        }

        pasos.push({ texto: '‚Üí NULL (fin de la lista)', tipo: 'info' });
        pasos.push({ texto: `‚úì Recorrido completado (${posicion - 1} nodos)`, tipo: 'exito' });
        setPasoAlgoritmo([...pasos]);
        setNodoActivo(null);
        setMensaje(`‚úÖ Recorrido completado`);
        setMetodoActual(null);
      };

      // Reiniciar
      const reiniciar = () => {
        const nuevaCabecera = new Nodo('P');
        nuevaCabecera.esCabecera = true;
        nuevaCabecera.sig = null;
        setCabecera(nuevaCabecera);
        setPasoAlgoritmo([]);
        setMensaje('');
        setNodoActivo(null);
        setNodoEncontrado(null);
      };

      // Crear ejemplo
      const crearEjemplo = () => {
        const nuevaCabecera = new Nodo('P');
        nuevaCabecera.esCabecera = true;
        
        const valores = ['A', 'B', 'C', 'D', 'E'];
        let actual = nuevaCabecera;
        
        valores.forEach(v => {
          const nuevoNodo = new Nodo(v);
          actual.sig = nuevoNodo;
          actual = nuevoNodo;
        });

        setCabecera(nuevaCabecera);
        setPasoAlgoritmo([
          { texto: 'Lista lineal de ejemplo creada', tipo: 'titulo' },
          { texto: 'Nodos: A ‚Üí B ‚Üí C ‚Üí D ‚Üí E ‚Üí NULL', tipo: 'info' },
          { texto: '¬°Prueba las operaciones!', tipo: 'exito' }
        ]);
        setMensaje('‚úÖ Lista lineal de ejemplo creada');
      };

      const nodos = obtenerNodos();
      const numNodos = nodos.length - 1;

      return (
        <div className="min-h-screen bg-gradient-to-br from-gray-900 via-blue-900 to-gray-900 text-white p-4">
          <div className="max-w-7xl mx-auto">
            {/* T√≠tulo */}
            <h1 className="text-3xl font-bold text-center mb-2 text-blue-300">
              üìã Lista Enlazada Simple (Lineal)
            </h1>
            <p className="text-center text-gray-400 mb-6">
              Lista enlazada donde el √∫ltimo nodo apunta a NULL
            </p>

            {/* Panel informativo */}
            {mostrarInfo && (
              <div className="bg-gray-800/50 rounded-xl p-6 mb-6 border border-blue-500/30">
                <div className="flex justify-between items-start">
                  <h2 className="text-xl font-bold text-blue-300 mb-4">üìö ¬øQu√© es una Lista Enlazada Simple?</h2>
                  <button onClick={() => setMostrarInfo(false)} className="text-gray-400 hover:text-white">‚úï</button>
                </div>
                
                <div className="grid md:grid-cols-2 gap-6">
                  <div>
                    <h3 className="font-bold text-blue-400 mb-2">Definici√≥n:</h3>
                    <p className="text-gray-300 text-sm mb-4">
                      Una <strong>Lista Enlazada Simple</strong> es la estructura m√°s b√°sica:
                    </p>
                    <ul className="text-sm text-gray-300 space-y-1 ml-4">
                      <li>‚Ä¢ Cada nodo tiene un <span className="text-blue-400">puntero sig</span> al siguiente</li>
                      <li>‚Ä¢ El <strong>√∫ltimo nodo apunta a NULL</strong></li>
                      <li>‚Ä¢ La condici√≥n de vac√≠a es: <code className="bg-gray-700 px-1 rounded">P.sig == NULL</code></li>
                      <li>‚Ä¢ La condici√≥n de fin es: <code className="bg-gray-700 px-1 rounded">Q == NULL</code></li>
                    </ul>
                  </div>
                  
                  <div>
                    <h3 className="font-bold text-yellow-400 mb-2">Caracter√≠sticas:</h3>
                    <ul className="text-sm text-gray-300 space-y-1 ml-4">
                      <li>‚úÖ Estructura m√°s simple de implementar</li>
                      <li>‚úÖ Menos memoria (solo un puntero)</li>
                      <li>‚úÖ Inserci√≥n/eliminaci√≥n al inicio en O(1)</li>
                      <li>‚ùå Solo recorrido hacia adelante</li>
                      <li>‚ùå Para eliminar necesitamos el nodo anterior</li>
                    </ul>
                  </div>
                </div>

                <div className="mt-4 p-3 bg-blue-900/30 rounded-lg">
                  <h3 className="font-bold text-blue-300 mb-2">üìã Estructura Lineal:</h3>
                  <div className="flex justify-center items-center gap-2 text-sm flex-wrap">
                    <div className="bg-gray-700 px-3 py-2 rounded border-2 border-blue-500">P</div>
                    <span className="text-gray-400">‚Üí</span>
                    <div className="bg-blue-700 px-3 py-2 rounded">A</div>
                    <span className="text-gray-400">‚Üí</span>
                    <div className="bg-blue-700 px-3 py-2 rounded">B</div>
                    <span className="text-gray-400">‚Üí</span>
                    <div className="bg-blue-700 px-3 py-2 rounded">C</div>
                    <span className="text-gray-400">‚Üí</span>
                    <span className="text-red-400 font-bold">NULL</span>
                  </div>
                </div>
              </div>
            )}

            <div className="grid lg:grid-cols-3 gap-6">
              {/* Panel de controles */}
              <div className="space-y-4">
                {/* Insertar */}
                <div className="bg-gray-800/50 rounded-xl p-4 border border-green-500/30">
                  <h3 className="font-bold text-green-400 mb-3">‚ûï Insertar</h3>
                  <input
                    type="text"
                    value={valor}
                    onChange={(e) => setValor(e.target.value)}
                    placeholder="Valor"
                    className="w-full bg-gray-700 rounded px-3 py-2 text-white mb-2"
                  />
                  <div className="grid grid-cols-2 gap-2 mb-2">
                    <button onClick={insertarAlInicio} disabled={metodoActual}
                      className="bg-green-600 hover:bg-green-500 disabled:opacity-50 px-3 py-2 rounded font-bold text-sm transition-colors">
                      Al Inicio
                    </button>
                    <button onClick={insertarAlFinal} disabled={metodoActual}
                      className="bg-green-600 hover:bg-green-500 disabled:opacity-50 px-3 py-2 rounded font-bold text-sm transition-colors">
                      Al Final
                    </button>
                  </div>
                  <input
                    type="text"
                    value={valorRef}
                    onChange={(e) => setValorRef(e.target.value)}
                    placeholder="Despu√©s de..."
                    className="w-full bg-gray-700 rounded px-3 py-2 text-white mb-2"
                  />
                  <button onClick={insertarDespuesDe} disabled={metodoActual}
                    className="w-full bg-green-700 hover:bg-green-600 disabled:opacity-50 px-3 py-2 rounded font-bold text-sm transition-colors">
                    Insertar Despu√©s De
                  </button>
                </div>

                {/* Buscar y Eliminar */}
                <div className="bg-gray-800/50 rounded-xl p-4 border border-blue-500/30">
                  <h3 className="font-bold text-blue-400 mb-3">üîç Buscar / Eliminar</h3>
                  <input
                    type="text"
                    value={valorBusqueda}
                    onChange={(e) => setValorBusqueda(e.target.value)}
                    placeholder="Dato"
                    className="w-full bg-gray-700 rounded px-3 py-2 text-white mb-2"
                  />
                  <div className="grid grid-cols-2 gap-2 mb-2">
                    <button onClick={buscarNodo} disabled={metodoActual}
                      className="bg-blue-600 hover:bg-blue-500 disabled:opacity-50 px-3 py-2 rounded font-bold text-sm transition-colors">
                      Buscar
                    </button>
                    <button onClick={eliminarPorDato} disabled={metodoActual}
                      className="bg-red-600 hover:bg-red-500 disabled:opacity-50 px-3 py-2 rounded font-bold text-sm transition-colors">
                      Eliminar
                    </button>
                  </div>
                  <div className="grid grid-cols-2 gap-2">
                    <button onClick={eliminarPrimero} disabled={metodoActual}
                      className="bg-red-700 hover:bg-red-600 disabled:opacity-50 px-3 py-2 rounded font-bold text-xs transition-colors">
                      Eliminar 1¬∞
                    </button>
                    <button onClick={eliminarUltimo} disabled={metodoActual}
                      className="bg-red-700 hover:bg-red-600 disabled:opacity-50 px-3 py-2 rounded font-bold text-xs transition-colors">
                      Eliminar √öltimo
                    </button>
                  </div>
                </div>

                {/* Acciones */}
                <div className="bg-gray-800/50 rounded-xl p-4 border border-yellow-500/30">
                  <h3 className="font-bold text-yellow-400 mb-3">üéÆ Acciones</h3>
                  <div className="space-y-2">
                    <button onClick={recorrido} disabled={metodoActual}
                      className="w-full bg-purple-600 hover:bg-purple-500 disabled:opacity-50 px-4 py-2 rounded font-bold transition-colors">
                      üìã Recorrido
                    </button>
                    <button onClick={crearEjemplo} disabled={metodoActual}
                      className="w-full bg-yellow-600 hover:bg-yellow-500 disabled:opacity-50 px-4 py-2 rounded font-bold transition-colors">
                      Crear Ejemplo
                    </button>
                    <button onClick={() => setMostrarInfo(!mostrarInfo)}
                      className="w-full bg-gray-600 hover:bg-gray-500 px-4 py-2 rounded font-bold transition-colors">
                      {mostrarInfo ? 'Ocultar' : 'Mostrar'} Info
                    </button>
                    <button onClick={reiniciar} disabled={metodoActual}
                      className="w-full bg-gray-700 hover:bg-gray-600 disabled:opacity-50 px-4 py-2 rounded font-bold transition-colors">
                      üîÑ Reiniciar
                    </button>
                  </div>
                  
                  <div className="mt-3">
                    <label className="text-xs text-gray-400">Velocidad:</label>
                    <input
                      type="range" min="200" max="1200"
                      value={1400 - velocidad}
                      onChange={(e) => setVelocidad(1400 - parseInt(e.target.value))}
                      className="w-full"
                    />
                  </div>
                </div>

                {mensaje && (
                  <div className={`p-3 rounded-lg text-center font-bold ${
                    mensaje.includes('‚úÖ') ? 'bg-green-900/50 text-green-300' :
                    mensaje.includes('‚ùå') ? 'bg-red-900/50 text-red-300' :
                    'bg-yellow-900/50 text-yellow-300'
                  }`}>
                    {mensaje}
                  </div>
                )}
              </div>

              {/* Visualizaci√≥n */}
              <div className="lg:col-span-1 bg-gray-800/30 rounded-xl p-4 border border-gray-700">
                <h3 className="font-bold text-gray-300 mb-4 text-center">üìã Visualizaci√≥n Lineal</h3>
                
                <div className="flex flex-wrap items-center justify-center gap-1 min-h-32">
                  {nodos.map((nodo, i) => (
                    <React.Fragment key={nodo.id}>
                      <div className={`
                        flex flex-col items-center p-2 rounded-lg border-2 transition-all duration-300
                        ${nodo.esCabecera ? 'bg-gray-700 border-blue-500' : 
                          nodoEncontrado === nodo.id ? 'bg-blue-600 border-blue-400 nodo-encontrado' :
                          nodoActivo === nodo.id ? 'bg-amber-600 border-amber-400 nodo-highlight' :
                          'bg-blue-700 border-blue-500'}
                      `}>
                        <div className="font-bold text-lg">
                          {nodo.esCabecera ? 'P' : nodo.dato}
                        </div>
                        {nodo.esCabecera && (
                          <div className="text-xs text-gray-400">cabecera</div>
                        )}
                      </div>
                      
                      {i < nodos.length - 1 && (
                        <div className="text-gray-400 px-1">‚Üí</div>
                      )}
                    </React.Fragment>
                  ))}
                  
                  <div className="text-gray-400 px-1">‚Üí</div>
                  <div className="bg-red-900/50 border border-red-600 px-2 py-1 rounded text-red-400 text-sm font-bold">
                    NULL
                  </div>
                </div>

                {numNodos === 0 && (
                  <div className="text-center text-gray-500 mt-4">
                    <p>Lista vac√≠a (P.sig = NULL)</p>
                  </div>
                )}

                <div className="flex justify-center gap-4 mt-4 text-xs">
                  <div className="flex items-center gap-1">
                    <div className="w-4 h-4 rounded bg-gray-700 border-2 border-blue-500"></div>
                    <span className="text-gray-400">Cabecera</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <div className="w-4 h-4 rounded bg-blue-700"></div>
                    <span className="text-gray-400">Nodo</span>
                  </div>
                  <div className="flex items-center gap-1">
                    <div className="w-4 h-4 rounded bg-amber-600"></div>
                    <span className="text-gray-400">Visitando</span>
                  </div>
                </div>

                <div className="mt-4 grid grid-cols-2 gap-2 text-center">
                  <div className="bg-gray-900/50 rounded p-2">
                    <p className="text-xl font-bold text-blue-400">{numNodos}</p>
                    <p className="text-xs text-gray-400">Nodos</p>
                  </div>
                  <div className="bg-gray-900/50 rounded p-2">
                    <p className="text-xl font-bold text-green-400">
                      {estaVacia() ? 'NULL' : cabecera.sig.dato}
                    </p>
                    <p className="text-xs text-gray-400">Primer nodo</p>
                  </div>
                </div>
              </div>

              {/* Panel de algoritmo */}
              <div className="bg-gray-800/30 rounded-xl p-4 border border-gray-700">
                <h3 className="font-bold text-gray-300 mb-3">üìä Algoritmo en Ejecuci√≥n</h3>
                
                <div className="bg-gray-900/50 rounded-lg p-3 h-96 overflow-y-auto font-mono text-sm">
                  {pasoAlgoritmo.length === 0 ? (
                    <div className="text-gray-500 text-center">
                      <p>Realiza una operaci√≥n para ver</p>
                      <p>el algoritmo paso a paso</p>
                    </div>
                  ) : (
                    pasoAlgoritmo.map((paso, i) => (
                      <div
                        key={i}
                        className={`mb-1 p-1 rounded ${
                          paso.tipo === 'titulo' ? 'font-bold text-blue-400 mt-2' :
                          paso.tipo === 'info' ? 'text-gray-300' :
                          paso.tipo === 'operacion' ? 'text-yellow-400 pl-4' :
                          paso.tipo === 'condicion' ? (paso.cumple ? 'text-green-400 pl-4' : 'text-orange-400 pl-4') :
                          paso.tipo === 'exito' ? 'text-green-400 bg-green-900/30 font-bold' :
                          paso.tipo === 'error' ? 'text-red-400 bg-red-900/30' :
                          paso.tipo === 'separador' ? 'border-t border-gray-700 my-2' :
                          'text-gray-400'
                        }`}
                      >
                        {paso.texto}
                      </div>
                    ))
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const { createRoot } = ReactDOM;
    const root = createRoot(document.getElementById("root"));
    root.render(<ListaLinealVisualizer />);
  </script>
</body>
</html>
